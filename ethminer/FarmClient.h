/**
* This file is generated by jsonrpcstub, DO NOT CHANGE IT MANUALLY!
*/

#ifndef JSONRPC_CPP_STUB_FARMCLIENT_H_
#define JSONRPC_CPP_STUB_FARMCLIENT_H_

#include <jsonrpccpp/client.h>
#include <ethminer/SignTx.h>
#include <libethash/sha3_cryptopp.h>
#include <iostream>
#include <fstream>
#include <sstream>
#include <boost/filesystem.hpp>

#ifndef _WIN32
#define stricmp strcasecmp
#endif

using namespace std;
using namespace dev;
using namespace dev::eth;


class FarmClient : public jsonrpc::Client
{
public:

	enum TxStatus
	{
		Succeeded,
		Failed,
		Waiting,
		NotFound
	};

	// Constructor
	FarmClient(
		jsonrpc::IClientConnector &conn,
		OperationMode _opMode,
		std::string _userAcct,
		jsonrpc::clientVersion_t type = jsonrpc::JSONRPC_CLIENT_V2
	) : jsonrpc::Client(conn, type)
	{
		m_opMode = _opMode;
		m_userAcct = _userAcct;
		m_tokenContract = ProgOpt::Get("0xBitcoin", "TokenContract");
		if (_opMode == OperationMode::Solo)
		{
			m_userAcctPK = ProgOpt::Get("0xBitcoin", "AcctPK");
			m_chainId = getChainId();
		}
	}

	void getWorkPool(bytes& _challenge, h256& _target, uint64_t& _difficulty, string& _hashingAcct)
	{
		jsonrpc::BatchCall batchCall = jsonrpc::BatchCall();

		Json::Value data;
		data.append(m_userAcct);

		// the first 2 calls don't need any parameter input, but there seems to be a bug in
		// the libjson-rpc-cpp package, such that it produces invalid JSON request if you just
		// do something like : batchCall.addCall("getChallengeNumber", Json::Value());
		// so I pass in some data which luckily the pool ignores, and sends me the information I want.

		int challengeID = batchCall.addCall("getChallengeNumber", data);
		int poolAddressID = batchCall.addCall("getPoolEthAddress", data);
		int targetID = batchCall.addCall("getMinimumShareTarget", data);
		int difficultyID = batchCall.addCall("getMinimumShareDifficulty", data);

		jsonrpc::BatchResponse response = CallProcedures(batchCall);

		if (response.getErrorCode(challengeID)) {
			LogB << "Error in getWorkPool: JSON-RPC call [challenge] - " << response.getErrorMessage(challengeID);
		}
		_challenge = fromHex(response.getResult(challengeID).asString());

		if (response.getErrorCode(targetID)) {
			LogB << "Error in getWorkPool: JSON-RPC call [target] - " << response.getErrorMessage(targetID);
		}
		m_target = u256(response.getResult(targetID).asString());

		if (response.getErrorCode(poolAddressID)) {
			LogB << "Error in getWorkPool: JSON-RPC call [poolAddress] - " << response.getErrorMessage(poolAddressID);
		}
		m_hashingAcct = response.getResult(poolAddressID).asString();

		if (response.getErrorCode(difficultyID)) {
			LogB << "Error in getWorkPool: JSON-RPC call [difficulty] - " << response.getErrorMessage(difficultyID);
		}
		m_difficulty = atoll(response.getResult(difficultyID).asString().c_str());

		_target = m_target;
		_difficulty = m_difficulty;
		_hashingAcct = m_hashingAcct;
		LogF << "Trace: getWorkPool - challenge:" << toHex(_challenge).substr(0, 8)
			<< ", target:" << std::hex << std::setw(16) << std::setfill('0') << upper64OfHash(_target)
			<< ", difficulty:" << std::dec << _difficulty;
	}

	void getWorkSolo(bytes& _challenge, h256& _target) throw (jsonrpc::JsonRpcException)
	{
		// challenge
		Json::Value p;
		p["from"] = m_userAcct;
		p["to"] = m_tokenContract;

		h256 bMethod = sha3("getChallengeNumber()");
		std::string sMethod = toHex(bMethod, dev::HexPrefix::Add);
		p["data"] = sMethod.substr(0, 10);

		Json::Value data;
		data.append(p);
		data.append("latest");

		Json::Value result = CallMethod("eth_call", data);
		if (result.isString())
		{
			_challenge = fromHex(result.asString());
		} else
			throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
		LogF << "Trace: getWork, Challenge : " << toHex(_challenge);

		// target
		bMethod = sha3("getMiningTarget()");
		sMethod = toHex(bMethod, dev::HexPrefix::Add);
		p["data"] = sMethod.substr(0, 10);

		data.clear();
		data.append(p);
		data.append("latest");

		result = CallMethod("eth_call", data);
		if (result.isString())
		{
			_target = h256(result.asString());
		}
		else
			throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());

	}

	void submitWorkPool(h256 _nonce, bytes _hash, bytes _challenge, uint64_t _difficulty)
	{
		LogF << "Trace: SubmitWorkPool, challenge = " << toHex(_challenge);
		LogF << "Trace: SubmitWorkPool, nonce = " << _nonce;
		LogF << "Trace: SubmitWorkPool, digest = " << toHex(_hash);
		Json::Value data;
		data.append("0x" + _nonce.hex());
		data.append(devFeeMining ? DonationAddress : m_userAcct);
		data.append("0x" + toHex(_hash));
		data.append((Json::UInt64)_difficulty);
		data.append("0x" + toHex(_challenge));
		Json::Value result = CallMethod("submitShare", data);
		//if (!result.isString() || result.asString() != "ok")
		//	LogB << "Solution was rejected by the pool! Reason : " << result.asString();
		if (!result.isBool() || !result.asBool())
			LogB << "Solution was rejected by the pool!";

	}

	void submitWorkSolo(h256 _nonce, bytes _hash, bytes _challenge)
	{

		try
		{
			// check if any other miner in our farm already submitted a solution for this challenge
			string folder = ProgOpt::Get("0xBitcoin", "ChallengeFolder");
			if (folder != "")
			{
				boost::filesystem::path m_challengeFilename = boost::filesystem::path(folder) / "challenge.txt";
				ifstream ifs;
				if (boost::filesystem::exists(m_challengeFilename))
				{
					string s;
					ifs.open(m_challengeFilename.generic_string(), fstream::in);
					getlineEx(ifs, s);
					if (s == toHex(_challenge))
					{
						LogS << "Another miner in the local farm already got this one : " << toHex(_challenge).substr(0, 8);
						return;
					}
				}
				ifs.close();
				// write this challenge value to our synchronization file.
				std::ofstream ofs(m_challengeFilename.generic_string(), std::ofstream::out);
				ofs << toHex(_challenge);
				ofs.close();
			}
		}
		catch (const std::exception& e)
		{
			LogB << "Exception: submitWorkSolo::CheckChallengeFolder - " << e.what();
		}


		// prepare transaction
		ProgOpt::Reload();
		Transaction t;
		t.chainId = m_chainId;
		if (m_lastSolution.elapsedSeconds() > 5 * 60 || m_txNonce == -1)
			m_txNonce = getNextNonce();
		else
			m_txNonce++;
		m_lastSolution.restart();
		t.nonce = m_txNonce;
		t.receiveAddress = toAddress(m_tokenContract);
		t.gas = atoi(ProgOpt::Get("0xBitcoin", "GasLimit", "200000").c_str());
		t.maxFee = u256(atof(ProgOpt::Get("Gas", "MaxFee").c_str()) * 1000000000);
		if (t.eip1559) {
			t.priorityFee = u256(atof(ProgOpt::Get("Gas", "MaxPriorityFee").c_str()) * 1000000000);
			if (t.priorityFee * t.maxFee == 0) {
				LogB << "ERROR: INVALID GAS VALUES. CHECK INI FILE. (MaxPriorityFee & MaxFee)";
			}
		} else {
			string gp = ProgOpt::Get("Gas", "GasPrice");
			LowerCase(gp);
			if (gp.find("oracle") != std::string::npos) {
				try {
					Json::Value result = CallMethod("eth_gasPrice", Json::Value());
					t.gasPrice = HexToInt(result.asString());
				} catch (const std::exception& e) {
					LogB << "EXCEPTION: Call to gas oracle failed - " << e.what();
				}
			} else {
				t.gasPrice = u256(atof(gp.c_str()) * 1000000000);
			}
			if (t.gasPrice * t.maxFee == 0) {
				LogB << "ERROR: INVALID GAS VALUES. CHECK INI FILE. (GasPrice & MaxFee)";
			}
			// don't go over max 
			t.gasPrice = min(t.gasPrice, t.maxFee);
		}

		// compute data parameter : first 4 bytes is hash of function signature
		h256 bMethod = sha3("mint(uint256,bytes32)");
		std::string sMethod = toHex(bMethod, dev::HexPrefix::Add);
		sMethod = sMethod.substr(0, 10);
		// put the nonce in
		stringstream ss;
		ss << std::setw(64) << std::setfill('0') << _nonce.hex();
		std::string s2(ss.str());
		sMethod = sMethod + s2;
		// and the hash
		ss = std::stringstream();
		ss << std::left << std::setw(64) << std::setfill('0') << toHex(_hash);
		s2 = std::string(ss.str());
		sMethod = sMethod + s2;
		t.data = fromHex(sMethod);
		t.value = 0;
		t.challenge = _challenge;

		txSignSend(t);
		u256 showPrice = t.eip1559 ? t.priorityFee : t.gasPrice;
		LogB << "Tx hash : " << t.txHash << ", gasPrice : " << showPrice.convert_to<double>() / 1000000000;
		m_pendingTxs.push_back(t);
	}

	int getNextNonce() {
		// get transaction count for nonce
		Json::Value p;
		p.append(m_userAcct);
		p.append("latest");
		Json::Value result = CallMethod("eth_getTransactionCount", p);
		return HexToInt(result.asString());
	}

	int getChainId() {
		try {
			Json::Value result = CallMethod("eth_chainId", Json::Value());
			return HexToInt(result.asString());
		} catch (const std::exception& e) {
			LogB << "ERROR RETRIEVING CHAIN ID: " << e.what();
		}
	}

	uint64_t tokenBalance() {
		static bool errorReported = false;
		Json::Value p;
		p["from"] = m_userAcct;
		p["to"] = m_tokenContract;

		h256 bMethod = sha3("balanceOf(address)");
		std::string sMethod = toHex(bMethod, dev::HexPrefix::Add);
		sMethod = sMethod.substr(0, 10);

		// address
		stringstream ss;
		ss << std::setw(64) << std::setfill('0') << m_userAcct.substr(2);
		std::string s2(ss.str());
		sMethod = sMethod + s2;
		p["data"] = sMethod;

		Json::Value data;
		data.append(p);
		data.append("latest");

		try
		{
			Json::Value result = CallMethod("eth_call", data);
			u256 balance = u256(result.asString()) / 100000000;
			errorReported = false;
			return static_cast<uint64_t>(balance);
		}
		catch (std::exception& e)
		{
			if (!errorReported) {
				LogD << "Error in routine tokenBalance: " << e.what();
			}
			errorReported = true;
			return 0;
		}
	}


	TxStatus getTxStatus(string _txHash)
	{
		Json::Value data;
		data.append(_txHash);
		try
		{
			// check if the tx still exists
			Json::Value result = CallMethod("eth_getTransactionByHash", data);
			if (result.isNull())
				return TxStatus::NotFound;

			// check if the tx has been mined
			result = CallMethod("eth_getTransactionReceipt", data);
			if (result["status"].asString() == "0x1")
				return TxStatus::Succeeded;
			else if (result["status"].asString() == "0x0")
				return TxStatus::Failed;
			else
				return TxStatus::Waiting;
		}
		catch (...)
		{
			return TxStatus::Waiting;
		}
	}

	void checkPendingTransactions()
	{
		vector<bytes> needsDeleting;

		for (int i = m_pendingTxs.size() - 1; i >= 0; i--)
		{
			Transaction t = m_pendingTxs[i];
			TxStatus status = getTxStatus(t.txHash);
			u256 showPrice = t.eip1559 ? t.priorityFee : t.gasPrice;
			if (status == Succeeded)
			{
				needsDeleting.push_back(t.challenge);
				LogB << "Tx " << t.txHash.substr(0, 10) << " succeeded, gasPrice = " << showPrice.convert_to<double>() / 1e9 << "  :)";
			}
			else if (status == Failed)
			{
				needsDeleting.push_back(t.challenge);
				LogB << "Tx " << t.txHash.substr(0, 10) << " failed, gasPrice = " << showPrice.convert_to<double>() /  1e9 << "  :(";
			}
			else if (status == Waiting)
			{
				// used to check if speed-up transaction was necessary
			}
		}

		for (auto challenge : needsDeleting)
		{
			for (int i = m_pendingTxs.size() - 1; i >= 0; i--)
			{
				if (m_pendingTxs[i].challenge == challenge)
					m_pendingTxs.erase(m_pendingTxs.begin() + i);
			}
		}
	}

	void txSignSend(Transaction &t)
	{
		stringstream ss;
		Secret pk = Secret(m_userAcctPK);
		t.sign(pk);
		ss = std::stringstream();
		ss << "0x" << toHex(t.rlp());

		// submit to the node
		Json::Value p;
		p.append(ss.str());
		Json::Value result = CallMethod("eth_sendRawTransaction", p);
		t.txHash = result.asString();
	}


	/*-----------------------------------------------------------------------------------
	* getBlockNumber
	*----------------------------------------------------------------------------------*/
	unsigned getBlockNumber()
	{
		try
		{
			Json::Value result = CallMethod("eth_blockNumber", Json::Value());
			return jsToInt(result.asString());
		}
		catch (const std::exception& e)
		{
			LogD << "Exception in getBlockNumber - " << e.what();
			return 0;
		}
	}


public:
	bool devFeeMining = false;

private:
	OperationMode m_opMode;
	string m_userAcctPK;
	string m_tokenContract;
	int m_txNonce = -1;
	Timer m_lastSolution;
	vector<Transaction> m_pendingTxs;
	int m_startGas;
	int m_maxGas;
	int m_bidTop;
	string m_userAcct;
	string m_hashingAcct = "";
	uint64_t m_difficulty;
	h256 m_target;
	int m_chainId;

};

#endif //JSONRPC_CPP_STUB_FARMCLIENT_H_
